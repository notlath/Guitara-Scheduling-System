import { useCallback, useEffect, useState } from "react";
import { useDispatch } from "react-redux";
import { useNavigate, useSearchParams } from "react-router-dom";
import {
  approveAttendance,
  fetchAttendanceRecords,
} from "../features/attendance/attendanceSlice";
import { logout } from "../features/auth/authSlice";
import {
  autoCancelOverdueAppointments,
  fetchAppointments,
  fetchNotifications,
  fetchStaffMembers,
  markAppointmentPaid,
  reviewRejection,
  updateAppointmentStatus,
} from "../features/scheduling/schedulingSlice";
import LayoutRow from "../globals/LayoutRow";
import PageLayout from "../globals/PageLayout";
import { useOperatorDashboardData } from "../hooks/useDashboardIntegration";
import useSyncEventHandlers from "../hooks/useSyncEventHandlers";
import styles from "../pages/SettingsDataPage/SettingsDataPage.module.css";
import syncService from "../services/syncService";
import { LoadingButton, LoadingSpinner, PageLoadingState, SkeletonLoader, InlineLoader, TableLoadingState } from "./common/LoadingComponents";
import AvailabilityManager from "./scheduling/AvailabilityManager";

import "../globals/TabSwitcher.css";
import "../styles/DriverCoordination.css";
import "../styles/OperatorDashboard.css";
import "../styles/LoadingConsistency.css";

const OperatorDashboard = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();

  // Set up sync event handlers to update Redux state
  useSyncEventHandlers();

  // URL search params for view persistence
  const [searchParams, setSearchParams] = useSearchParams();

  // Get view from URL params, default to 'rejected'
  const currentView = searchParams.get("view") || "rejected";

  // Helper function to update view in URL
  const setView = (newView) => {
    const newSearchParams = new URLSearchParams(searchParams);
    newSearchParams.set("view", newView);
    setSearchParams(newSearchParams);
  };
  const [reviewModal, setReviewModal] = useState({
    isOpen: false,
    appointmentId: null,
    rejectionReason: "",
  });
  const [reviewNotes, setReviewNotes] = useState("");
  const [autoCancelLoading, setAutoCancelLoading] = useState(false);

  // Loading states for individual button actions
  const [buttonLoading, setButtonLoading] = useState({});
  // Helper function to set loading state for specific action
  const setActionLoading = (actionKey, isLoading) => {
    console.log(`🔄 setActionLoading: ${actionKey} = ${isLoading}`);
    setButtonLoading((prev) => {
      const newState = {
        ...prev,
        [actionKey]: isLoading,
      };
      console.log("🔍 setActionLoading: New button loading state:", newState);
      return newState;
    });
  };
  // Force clear loading state for emergency situations
  const _forceClearLoading = (actionKey) => {
    console.log(`🚨 forceClearLoading: Forcing clear for ${actionKey}`);
    setButtonLoading((prev) => {
      const newState = { ...prev };
      delete newState[actionKey];
      return newState;
    });
  };
  // Payment verification modal state
  const [paymentModal, setPaymentModal] = useState({
    isOpen: false,
    appointmentId: null,
    appointmentDetails: null,
  });
  const [paymentData, setPaymentData] = useState({
    method: "cash",
    amount: "",
    notes: "",
  });
  // Attendance-related state
  const [attendanceRecords, setAttendanceRecords] = useState([]);
  const [attendanceLoading, setAttendanceLoading] = useState(false);
  const [selectedDate, setSelectedDate] = useState(
    new Date().toISOString().split("T")[0]
  );
  // Driver coordination state
  const [driverAssignment, setDriverAssignment] = useState({
    availableDrivers: [],
    busyDrivers: [],
    pendingPickups: [],
  });  // Get state from Redux store
  const {
    rejectedAppointments,
    pendingAppointments,
    awaitingPaymentAppointments,
    overdueAppointments,
    approachingDeadlineAppointments,
    activeSessions,
    pickupRequests,
    rejectionStats,
    appointments,
    todayAppointments,
    upcomingAppointments,
    notifications,
    loading,
    error,
    isInitialLoad,
    refreshData,
  } = useOperatorDashboardData();
  // Helper function to get driver task description based on appointment status
  const getDriverTaskDescription = (appointment) => {
    if (!appointment) return "On assignment";

    const therapistName = appointment.therapist_details
      ? `${appointment.therapist_details.first_name} ${appointment.therapist_details.last_name}`
      : appointment.therapist_name || "therapist";

    switch (appointment.status) {
      case "driver_confirmed":
        return `Ready to transport ${therapistName}`;
      case "in_progress":
        return `Starting journey - picking up ${therapistName}`;
      case "journey_started":
      case "journey":
        return `Transporting ${therapistName} to client location`;
      case "arrived":
        return `Arrived - dropping off ${therapistName}`;
      case "return_journey":
        return `Return journey - picking up ${therapistName}`;
      case "driver_assigned_pickup":
        return `Assigned pickup for ${therapistName}`;
      default:
        return `Active with ${therapistName}`;
    }
  };

  // Load driver data on component mount and refresh
  useEffect(() => {
    const loadDriverData = async () => {
      try {
        // Fetch real staff data from backend
        const staffResponse = await dispatch(fetchStaffMembers()).unwrap();

        // Filter drivers and categorize by availability status
        const drivers = staffResponse.filter(
          (staff) => staff.role === "driver"
        ); // Get current appointments to determine driver status
        // Note: "dropped_off" is NOT included here, so drivers who dropped off therapists will be available
        const activeAppointmentStatuses = [
          "driver_confirmed",
          "in_progress",
          "journey_started",
          "journey",
          "arrived",
          "return_journey", // Driver is en route to pick up therapist after session
          "driver_assigned_pickup", // Driver assigned for pickup but hasn't confirmed yet
        ]; // Find drivers with active appointments (busy)
        const busyDriverIds = (appointments || [])
          .filter(
            (apt) =>
              activeAppointmentStatuses.includes(apt.status) && apt.driver
          )
          .map((apt) => apt.driver);

        // Categorize drivers
        const availableDrivers = [];
        const busyDrivers = [];
        drivers.forEach((driver) => {
          // Find the current appointment for this driver
          const currentAppointment = (appointments || []).find(
            (apt) =>
              activeAppointmentStatuses.includes(apt.status) &&
              apt.driver === driver.id
          );

          const driverData = {
            id: driver.id,
            first_name: driver.first_name,
            last_name: driver.last_name,
            role: driver.role,
            specialization: driver.specialization,
            vehicle_type: driver.vehicle_type || "Motorcycle",
            current_location: driver.current_location || "Available",
            last_available_at: driver.last_available_at,
            last_drop_off_time: driver.last_drop_off_time,
            last_vehicle_used:
              driver.last_vehicle_used || driver.vehicle_type || "Motorcycle",
            last_location: driver.current_location || "Available",
            available_since:
              driver.last_available_at || new Date().toISOString(),
            status: busyDriverIds.includes(driver.id) ? "busy" : "available", // Enhanced appointment details for busy drivers
            currentAppointment: currentAppointment,
            current_task: currentAppointment
              ? getDriverTaskDescription(currentAppointment)
              : null,
            therapist_name: currentAppointment?.therapist_details
              ? `${currentAppointment.therapist_details.first_name} ${currentAppointment.therapist_details.last_name}`
              : currentAppointment?.therapist_name || "Unknown Therapist",
            client_name:
              currentAppointment?.client_details?.name ||
              currentAppointment?.client_name ||
              "Unknown Client",
            appointment_status: currentAppointment?.status,
            appointment_location: currentAppointment?.location,
          };

          if (busyDriverIds.includes(driver.id)) {
            busyDrivers.push(driverData);
          } else {
            availableDrivers.push(driverData);
          }
        });

        setDriverAssignment({
          availableDrivers,
          busyDrivers,
          pendingPickups: [],
        });
      } catch (error) {
        console.error("Failed to load driver data:", error);
        // Fallback to mock data if API fails
        setDriverAssignment({
          availableDrivers: [
            {
              id: 1,
              first_name: "Juan",
              last_name: "Dela Cruz",
              vehicle_type: "Motorcycle",
              last_location: "Quezon City",
              available_since: new Date().toISOString(),
              status: "available",
            },
            {
              id: 2,
              first_name: "Maria",
              last_name: "Santos",
              vehicle_type: "Car",
              last_location: "Makati",
              available_since: new Date().toISOString(),
              status: "available",
            },
          ],
          busyDrivers: [
            {
              id: 3,
              first_name: "Jose",
              last_name: "Garcia",
              vehicle_type: "Motorcycle",
              current_task: "Transporting therapist to session",
              estimated_completion: new Date(
                Date.now() + 30 * 60000
              ).toISOString(),
              status: "busy",
            },
          ],
          pendingPickups: [],
        });
      }
    }; // Only load data if appointments is available (not undefined)
    if (appointments !== undefined) {
      const loadInitialData = async () => {
        await loadDriverData();
        // Also fetch notifications on initial load
        dispatch(fetchNotifications());
      };
      loadInitialData();
    }
  }, [dispatch, appointments]);
  // Listen for real-time driver updates via sync service
  useEffect(() => {
    const handleDriverUpdate = (data) => {
      setDriverAssignment((prev) => {
        switch (data.type) {
          case "driver_available":
            return {
              ...prev,
              availableDrivers: [
                ...prev.availableDrivers.filter((d) => d.id !== data.driver_id),
                data.driver,
              ],
              busyDrivers: prev.busyDrivers.filter(
                (d) => d.id !== data.driver_id
              ),
            };
          case "driver_assigned":
            return {
              ...prev,
              availableDrivers: prev.availableDrivers.filter(
                (d) => d.id !== data.driver_id
              ),
              busyDrivers: [
                ...prev.busyDrivers.filter((d) => d.id !== data.driver_id),
                data.driver,
              ],
            };
          case "pickup_requested":
            return {
              ...prev,
              pendingPickups: [
                ...prev.pendingPickups.filter(
                  (p) => p.id !== data.therapist_id
                ),
                data.therapist,
              ],
            };
          default:
            return prev;
        }
      });
    };

    // Subscribe to driver-related events and store the unsubscribe function
    const unsubscribe = syncService.subscribe(
      "driver_update",
      handleDriverUpdate
    );

    return () => {
      unsubscribe();
    };
  }, []);
  // 🔥 REMOVED: All redundant filtering and memoized computations
  // The useOperatorDashboardData hook provides all filtered data

  // 🔥 REMOVED: Old redundant polling - now handled by centralized DataManager
  // Real-time sync is handled by useSyncEventHandlers hook and centralized data manager

  // Load data on component mount
  useEffect(() => {
    refreshData();
  }, [refreshData]);

  // Real-time timer for updating countdown displays
  useEffect(() => {
    const timer = setInterval(() => {
      // Force re-render every second to update countdown timers
      if (currentView === "timeouts" && pendingAppointments.length > 0) {
        // This will trigger a re-render to update the countdown timers
        setReviewNotes((prev) => prev); // Dummy state update to trigger re-render
      }
    }, 1000);
    return () => clearInterval(timer);
  }, [currentView, pendingAppointments.length]);
  // Helper function to display therapist information (single or multiple)
  const renderTherapistInfo = (appointment) => {
    // Handle multiple therapists
    if (
      appointment.therapists_details &&
      appointment.therapists_details.length > 0
    ) {
      return (
        <div className="detail-row">
          <span className="label">Therapists:</span>
          <div className="therapists-list">
            {appointment.therapists_details.map((therapist) => (
              <div key={therapist.id} className="therapist-name">
                {therapist.first_name} {therapist.last_name}
                {therapist.specialization && (
                  <span className="therapist-specialization">
                    {" "}
                    ({therapist.specialization})
                  </span>
                )}
              </div>
            ))}
          </div>
        </div>
      );
    }

    // Handle single therapist (legacy support)
    if (appointment.therapist_details) {
      return (
        <div className="detail-row">
          <span className="label">Therapist:</span>
          <div className="therapist-name">
            {appointment.therapist_details.first_name}{" "}
            {appointment.therapist_details.last_name}
            {appointment.therapist_details.specialization && (
              <span className="therapist-specialization">
                {" "}
                ({appointment.therapist_details.specialization})
              </span>
            )}
          </div>
        </div>
      );
    }

    return (
      <div className="detail-row">
        <span className="label">Therapist:</span>
        <span className="no-therapist">No therapist assigned</span>
      </div>
    );
  };
  // Helper function to get therapist acceptance status
  const getTherapistAcceptanceStatus = (appointment) => {
    // Handle multiple therapists
    if (
      appointment.therapists_details &&
      appointment.therapists_details.length > 0
    ) {
      const acceptedCount = appointment.therapists_details.filter(
        (_, index) =>
          appointment.therapists_accepted &&
          appointment.therapists_accepted[index]
      ).length;
      const totalCount = appointment.therapists_details.length;

      if (acceptedCount === totalCount) {
        return (
          <span className="acceptance-indicator accepted">All accepted ✓</span>
        );
      } else if (acceptedCount > 0) {
        return (
          <span className="acceptance-indicator partial">
            {acceptedCount}/{totalCount} accepted ⏳
          </span>
        );
      } else {
        return <span className="acceptance-indicator pending">Pending ⏳</span>;
      }
    }

    // Handle single therapist (legacy support)
    if (appointment.therapist_details) {
      return appointment.therapist_accepted ? (
        <span className="acceptance-indicator accepted">Accepted ✓</span>
      ) : (
        <span className="acceptance-indicator pending">Pending ⏳</span>
      );
    }

    return (
      <span className="acceptance-indicator no-therapist">No therapist</span>
    );
  };

  const handleLogout = () => {
    localStorage.removeItem("knoxToken");
    localStorage.removeItem("user");
    dispatch(logout());
    navigate("/");
  };

  const handleReviewRejection = (appointment) => {
    setReviewModal({
      isOpen: true,
      appointmentId: appointment.id,
      rejectionReason: appointment.rejection_reason || "",
    });
    setReviewNotes("");
  };
  const handleReviewSubmit = async (decision) => {
    const actionKey = `review_${reviewModal.appointmentId}_${decision}`;
    try {
      setActionLoading(actionKey, true);
      await dispatch(
        reviewRejection({
          id: reviewModal.appointmentId,
          reviewDecision: decision,
          reviewNotes: reviewNotes,
        })
      ).unwrap();
      refreshData();
      setReviewModal({
        isOpen: false,
        appointmentId: null,
        rejectionReason: "",
      });
      setReviewNotes("");
    } catch {
      alert("Failed to review rejection. Please try again.");
    } finally {
      setActionLoading(actionKey, false);
    }
  };
  const handleReviewCancel = () => {
    setReviewModal({ isOpen: false, appointmentId: null, rejectionReason: "" });
    setReviewNotes("");
  };
  const handleAutoCancelOverdue = async () => {
    if (
      !window.confirm(
        "This will auto-cancel all overdue appointments and disable therapists who didn't respond. Continue?"
      )
    ) {
      return;
    }

    setAutoCancelLoading(true);
    try {
      await dispatch(autoCancelOverdueAppointments()).unwrap();
      refreshData();
      alert("Successfully processed overdue appointments");
    } catch {
      alert("Failed to process overdue appointments. Please try again.");
    } finally {
      setAutoCancelLoading(false);
    }
  };
  const handleStartAppointment = async (appointmentId) => {
    const actionKey = `start_${appointmentId}`;
    try {
      setActionLoading(actionKey, true);
      await dispatch(
        updateAppointmentStatus({
          id: appointmentId,
          status: "in_progress",
          action: "start_appointment",
        })
      ).unwrap();

      // Refresh appointments to get updated status
      dispatch(fetchAppointments());
    } catch (error) {
      console.error("Failed to start appointment:", error);
      alert("Failed to start appointment. Please try again.");
    } finally {
      setActionLoading(actionKey, false);
    }
  }; // Payment verification handler
  const handlePaymentVerification = (appointment) => {
    // Calculate total amount from services with proper number handling
    const totalAmount =
      appointment?.services_details?.reduce((total, service) => {
        const price = Number(service.price) || 0;
        return total + price;
      }, 0) || 0;

    setPaymentModal({
      isOpen: true,
      appointmentId: appointment.id,
      appointmentDetails: appointment,
    });
    setPaymentData({
      method: "cash",
      amount: totalAmount.toFixed(2), // totalAmount is guaranteed to be a number
      notes: "",
    });
  };
  const handleMarkPaymentPaid = async () => {
    const actionKey = `payment_${paymentModal.appointmentId}`;

    console.log("🔍 handleMarkPaymentPaid: Starting with data:", {
      actionKey,
      appointmentId: paymentModal.appointmentId,
      paymentData,
      currentButtonLoading: buttonLoading[actionKey],
    });

    // Validate payment data
    if (!paymentData.amount || parseFloat(paymentData.amount) <= 0) {
      console.log(
        "❌ handleMarkPaymentPaid: Invalid payment amount",
        paymentData.amount
      );
      alert("Please enter a valid payment amount.");
      return;
    }

    try {
      console.log(
        "🔄 handleMarkPaymentPaid: Setting loading state to true for",
        actionKey
      );
      setActionLoading(actionKey, true);

      // Safety timeout to clear loading state after 30 seconds
      const safetyTimeout = setTimeout(() => {
        console.log(
          "🚨 handleMarkPaymentPaid: Safety timeout triggered, clearing loading state"
        );
        _forceClearLoading(actionKey);
      }, 30000);

      // Pass the appointment ID as a number, not an object
      const appointmentId = parseInt(paymentModal.appointmentId, 10);
      console.log("🔍 handleMarkPaymentPaid: Dispatching markAppointmentPaid", {
        appointmentId,
        paymentData,
        actionKey,
      });

      const result = await dispatch(
        markAppointmentPaid({
          appointmentId,
          paymentData,
        })
      ).unwrap();

      console.log(
        "✅ handleMarkPaymentPaid: Payment verification successful",
        result
      );

      // Clear the safety timeout since operation completed successfully
      clearTimeout(safetyTimeout);

      // Close modal and refresh data
      setPaymentModal({
        isOpen: false,
        appointmentId: null,
        appointmentDetails: null,
      });
      setPaymentData({
        method: "cash",
        amount: "",
        notes: "",
      });

      console.log("🔄 handleMarkPaymentPaid: Refreshing dashboard data");
      refreshData();

      alert("Payment marked as received successfully!");
    } catch (error) {
      console.error("❌ handleMarkPaymentPaid: Error occurred:", error);

      // Show more detailed error information
      const errorMessage =
        error?.message || error?.error || error || "Unknown error occurred";
      alert(`Failed to mark payment as paid: ${errorMessage}`);
    } finally {
      console.log(
        "🔄 handleMarkPaymentPaid: Setting loading state to false for",
        actionKey
      );
      setActionLoading(actionKey, false);

      // Add a small delay to ensure state update completes
      setTimeout(() => {
        console.log("🔍 handleMarkPaymentPaid: Loading state after cleanup:", {
          actionKey,
          isLoading: buttonLoading[actionKey],
        });
      }, 100);
    }
  };
  const handlePaymentModalCancel = () => {
    // Clear any payment-related loading states when modal is cancelled
    const appointmentId = paymentModal.appointmentId;
    if (appointmentId) {
      const paymentActionKey = `payment_${appointmentId}`;
      console.log(
        "🔄 handlePaymentModalCancel: Clearing loading state for",
        paymentActionKey
      );
      setActionLoading(paymentActionKey, false);
    }

    setPaymentModal({
      isOpen: false,
      appointmentId: null,
      appointmentDetails: null,
    });
    setPaymentData({
      method: "cash",
      amount: "",
      notes: "",
    });
  }; // Driver coordination functions - Pure FIFO system (no proximity filtering)
  const handleAssignDriverPickup = useCallback(
    async (therapistId, driverId = null) => {
      // Helper function to get urgency level based on request time
      const getUrgencyLevel = (requestTime) => {
        if (!requestTime) return "normal";
        const waitTime = (new Date() - new Date(requestTime)) / (1000 * 60); // minutes
        return waitTime > 20 ? "urgent" : "normal"; // Reduced to 20 minutes for Pasig City
      };

      try {
        // Get current pending pickup requests from appointments
        const currentPendingPickups = appointments
          .filter((apt) => apt.status === "pickup_requested")
          .map((apt) => ({
            id: apt.therapist,
            name: apt.therapist_details
              ? `${apt.therapist_details.first_name} ${apt.therapist_details.last_name}`
              : "Unknown Therapist",
            location: apt.location,
            appointment_id: apt.id,
            urgency: getUrgencyLevel(apt.pickup_request_time),
            session_end_time: apt.session_end_time,
            requested_at: apt.pickup_request_time,
          }));

        const therapist = currentPendingPickups.find(
          (t) => t.id === therapistId
        );

        if (!therapist) {
          alert("Invalid therapist selection");
          return;
        }

        // Pure FIFO driver selection - get the driver who became available first
        let driver;
        if (driverId) {
          // Manual assignment: use specific driver
          driver = driverAssignment.availableDrivers.find(
            (d) => d.id === driverId
          );
        } else {
          // Auto-assignment: Pure FIFO - first available driver based on last drop-off or availability time
          const availableDriversSorted = driverAssignment.availableDrivers.sort(
            (a, b) => {
              // Use last_drop_off_time if available, otherwise use available_since
              const timeA = new Date(
                a.last_drop_off_time || a.last_available_at || a.available_since
              );
              const timeB = new Date(
                b.last_drop_off_time || b.last_available_at || b.available_since
              );
              return timeA - timeB;
            }
          );
          driver = availableDriversSorted[0];

          // Show FIFO selection details
          const queuePosition =
            availableDriversSorted.findIndex((d) => d.id === driver.id) + 1;
          console.log(
            `🎯 FIFO Assignment: Selected driver ${driver.first_name} ${driver.last_name} (Position #${queuePosition} in queue)`
          );
        }
        if (!driver) {
          alert("No drivers available for assignment");
          return;
        }

        // Fixed estimated arrival time - no proximity calculations
        const estimatedTime = 20; // Standard 20 minutes for all assignments
        const estimatedArrival = new Date();
        estimatedArrival.setMinutes(
          estimatedArrival.getMinutes() + estimatedTime
        );

        // Calculate queue position for detailed FIFO information
        const sortedDrivers = driverAssignment.availableDrivers.sort((a, b) => {
          const timeA = new Date(
            a.last_drop_off_time || a.last_available_at || a.available_since
          );
          const timeB = new Date(
            b.last_drop_off_time || b.last_available_at || b.available_since
          );
          return timeA - timeB;
        });
        const queuePosition =
          sortedDrivers.findIndex((d) => d.id === driver.id) + 1;

        // Update appointment status with detailed FIFO information
        await dispatch(
          updateAppointmentStatus({
            id: therapist.appointment_id,
            status: "driver_assigned_pickup",
            driver: driver.id,
            notes: `Driver assigned for pickup via FIFO Algorithm (Queue Position: #${queuePosition}) - ETA: ${estimatedTime} minutes`,
          })
        ).unwrap();

        // Move driver from available to busy
        setDriverAssignment((prev) => ({
          ...prev,
          availableDrivers: prev.availableDrivers.filter(
            (d) => d.id !== driver.id
          ),
          busyDrivers: [
            ...prev.busyDrivers.filter((d) => d.id !== driver.id),
            {
              ...driver,
              current_task: `Picking up ${therapist.name}`,
              current_location: `En route to ${therapist.location}`,
            },
          ],
          pendingPickups: prev.pendingPickups.filter(
            (t) => t.id !== therapistId
          ),
        }));

        // Broadcast assignment with FIFO indicator
        syncService.broadcast("driver_assigned_pickup", {
          driver_id: driver.id,
          therapist_id: therapistId,
          appointment_id: therapist.appointment_id,
          estimated_arrival: estimatedArrival.toISOString(),
          driver_name: `${driver.first_name} ${driver.last_name}`,
          therapist_name: therapist.name,
          pickup_location: therapist.location,
          estimated_time: estimatedTime,
          assignment_method: "FIFO",
        });
        refreshData();

        // Show success notification with FIFO details
        alert(
          `✅ FIFO Assignment Successful!\n\nDriver: ${driver.first_name} ${driver.last_name}\nQueue Position: #${queuePosition}\nTherapist: ${therapist.name}\nLocation: ${therapist.location}\nETA: ${estimatedTime} minutes`
        );
      } catch (error) {
        console.error("Failed to assign driver:", error);
        alert("Failed to assign driver. Please try again.");
      }
    },
    [
      appointments,
      driverAssignment.availableDrivers,
      dispatch,
      refreshData,
      setDriverAssignment,
    ]
  );
  const _handleUrgentPickupRequest = async (therapistId) => {
    try {
      // For urgent requests, still use FIFO but assign immediately
      const availableDrivers = driverAssignment.availableDrivers;

      if (availableDrivers.length === 0) {
        alert("No drivers currently available for urgent pickup");
        return;
      }

      // Pure FIFO - use first available driver regardless of location
      const firstAvailableDriver = availableDrivers.sort(
        (a, b) => new Date(a.available_since) - new Date(b.available_since)
      )[0];

      await handleAssignDriverPickup(therapistId, firstAvailableDriver.id);
    } catch (error) {
      console.error("Failed to process urgent pickup request:", error);
      alert("Failed to process urgent pickup request");
    }
  };

  const _getTimeElapsed = (timestamp) => {
    const now = new Date();
    const past = new Date(timestamp);
    const diffMs = now - past;
    const diffMins = Math.floor(diffMs / 60000);

    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins} min ago`;
    const diffHours = Math.floor(diffMins / 60);
    return `${diffHours}h ${diffMins % 60}m ago`;
  };
  // Helper functions for FIFO coordination
  const _getDriverFIFOPosition = (driver) => {
    const sorted = driverAssignment.availableDrivers.sort(
      (a, b) => new Date(a.available_since) - new Date(b.available_since)
    );
    return sorted.findIndex((d) => d.id === driver.id) + 1;
  };
  // Smart FIFO auto-assignment function
  const handleAutoAssignPickupRequest = useCallback(
    async (pickupRequest) => {
      try {
        console.log(
          "🤖 Auto-assigning pickup request using FIFO:",
          pickupRequest
        );

        // Get available drivers sorted by FIFO (earliest available first)
        const availableDrivers = driverAssignment.availableDrivers
          .filter((driver) => driver.status === "available")
          .sort((a, b) => {
            const timeA = new Date(a.last_available_at || a.available_since);
            const timeB = new Date(b.last_available_at || b.available_since);
            return timeA - timeB; // Earliest first (FIFO)
          });

        if (availableDrivers.length === 0) {
          console.log("❌ No drivers available for auto-assignment");
          return false;
        }

        // Get the first available driver (FIFO)
        const nextDriver = availableDrivers[0];

        console.log(
          `✅ Auto-assigning driver ${nextDriver.first_name} ${nextDriver.last_name} (FIFO position: 1)`
        );

        // Auto-assign the driver
        await handleAssignDriverPickup(
          pickupRequest.therapist_id,
          nextDriver.id
        );

        // Broadcast auto-assignment notification
        syncService.broadcast("auto_assignment_completed", {
          pickup_request: pickupRequest,
          assigned_driver: nextDriver,
          assignment_method: "FIFO",
          assignment_time: new Date().toISOString(),
          message: `Driver ${nextDriver.first_name} ${nextDriver.last_name} auto-assigned via FIFO`,
        });

        return true;
      } catch (error) {
        console.error("Failed to auto-assign pickup request:", error);
        return false;
      }
    },
    [driverAssignment.availableDrivers, handleAssignDriverPickup]
  );
  // Listen for pickup requests and auto-assign drivers
  useEffect(() => {
    const handlePickupRequest = async (data) => {
      console.log("🚖 Pickup request received:", data);

      // Auto-assign driver if available
      if (data.therapist_id) {
        const assigned = await handleAutoAssignPickupRequest({
          therapist_id: data.therapist_id,
          appointment_id: data.appointment_id,
          location: data.location,
          urgency: data.pickup_urgency || "normal",
          timestamp: data.timestamp,
        });

        if (assigned) {
          // Notify therapist that driver has been assigned
          syncService.broadcast("pickup_auto_assigned", {
            therapist_id: data.therapist_id,
            appointment_id: data.appointment_id,
            assignment_method: "auto_fifo",
            message: "Driver automatically assigned for pickup",
          });
        }
      }
    };

    // Subscribe to pickup request events
    const unsubscribePickup = syncService.subscribe(
      "pickup_requested",
      handlePickupRequest
    );

    return () => {
      unsubscribePickup();
    };
  }, [handleAutoAssignPickupRequest]); // Re-subscribe when auto-assignment function changes

  // Attendance handlers
  const handleFetchAttendanceRecords = useCallback(async () => {
    try {
      setAttendanceLoading(true);
      const result = await dispatch(
        fetchAttendanceRecords({ date: selectedDate })
      ).unwrap();
      setAttendanceRecords(result);
    } catch (error) {
      console.error("Failed to fetch attendance records:", error);
    } finally {
      setAttendanceLoading(false);
    }
  }, [dispatch, selectedDate]);

  const handleApproveAttendance = async (attendanceId) => {
    const actionKey = `approve_${attendanceId}`;
    try {
      setActionLoading(actionKey, true);
      await dispatch(approveAttendance(attendanceId)).unwrap();
      // Refresh attendance records
      await handleFetchAttendanceRecords();
    } catch (error) {
      console.error("Failed to approve attendance:", error);
      alert("Failed to approve attendance. Please try again.");
    } finally {
      setActionLoading(actionKey, false);
    }
  };

  const handleDateChange = (newDate) => {
    setSelectedDate(newDate);
  };

  // Load attendance records when date changes
  useEffect(() => {
    if (currentView === "attendance") {
      handleFetchAttendanceRecords();
    }
  }, [currentView, handleFetchAttendanceRecords]);

  // Render attendance management view
  const renderAttendanceView = () => {
    const getStatusColor = (status) => {
      switch (status) {
        case "present":
          return "#28a745";
        case "late":
          return "#ffc107";
        case "absent":
          return "#dc3545";
        case "pending_approval":
          return "#007bff";
        default:
          return "#6c757d";
      }
    };

    const getStatusBadge = (status) => {
      const configs = {
        present: { icon: "✅", label: "Present" },
        late: { icon: "⏰", label: "Late" },
        absent: { icon: "❌", label: "Absent" },
        pending_approval: { icon: "⏳", label: "Pending Approval" },
      };
      const config = configs[status] || { icon: "❓", label: "Unknown" };
      return (
        <span
          className="status-badge"
          style={{
            backgroundColor: getStatusColor(status),
            color: "white",
            padding: "4px 8px",
            borderRadius: "4px",
            fontSize: "12px",
          }}
        >
          {config.icon} {config.label}
        </span>
      );
    };
    const formatTime = (timeString) => {
      if (!timeString) return "--:--";

      // If it's already a full datetime string, parse it directly
      if (timeString.includes("T") || timeString.includes(" ")) {
        return new Date(timeString).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      }

      // If it's just a time string (HH:MM:SS), create a proper date
      try {
        const [hours, minutes, seconds] = timeString.split(":").map(Number);

        // Validate the time components
        if (
          isNaN(hours) ||
          isNaN(minutes) ||
          hours < 0 ||
          hours > 23 ||
          minutes < 0 ||
          minutes > 59
        ) {
          console.error("Invalid time format:", timeString);
          return timeString; // Return original string if invalid
        }

        const today = new Date();
        const dateTime = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate(),
          hours,
          minutes,
          seconds || 0
        );
        return dateTime.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      } catch (error) {
        console.error("Error formatting time:", timeString, error);
        return timeString; // Return original string on error
      }
    };

    return (
      <div className="attendance-management-panel">
        <div className="attendance-header">
          <div className="date-selector">
            <label htmlFor="attendance-date">Select Date:</label>
            <input
              id="attendance-date"
              type="date"
              value={selectedDate}
              onChange={(e) => handleDateChange(e.target.value)}
              className="date-input"
            />
            <LoadingButton
              onClick={handleFetchAttendanceRecords}
              loading={attendanceLoading}
              className="refresh-btn"
            >
              Refresh
            </LoadingButton>
          </div>
        </div>

        {attendanceLoading ? (
          <div className="loading-state">
            <LoadingSpinner text="Loading attendance records..." />
          </div>
        ) : attendanceRecords.length === 0 ? (
          <div className="empty-state">
            <i className="fas fa-calendar-check"></i>
            <p>No attendance records found for {selectedDate}</p>
          </div>
        ) : (
          <div className="attendance-records">
            <div className="attendance-summary">
              <div className="summary-stats">
                <div className="stat-card present">
                  <span className="stat-number">
                    {
                      attendanceRecords.filter((r) => r.status === "present")
                        .length
                    }
                  </span>
                  <span className="stat-label">Present</span>
                </div>
                <div className="stat-card late">
                  <span className="stat-number">
                    {
                      attendanceRecords.filter((r) => r.status === "late")
                        .length
                    }
                  </span>
                  <span className="stat-label">Late</span>
                </div>
                <div className="stat-card absent">
                  <span className="stat-number">
                    {
                      attendanceRecords.filter((r) => r.status === "absent")
                        .length
                    }
                  </span>
                  <span className="stat-label">Absent</span>
                </div>
                <div className="stat-card pending">
                  <span className="stat-number">
                    {
                      attendanceRecords.filter(
                        (r) => r.status === "pending_approval"
                      ).length
                    }
                  </span>
                  <span className="stat-label">Pending Approval</span>
                </div>
              </div>
            </div>

            <div className="attendance-list">
              {attendanceRecords.map((record) => (
                <div key={record.id} className="attendance-card">
                  <div className="attendance-info">
                    <div className="staff-details">
                      <h4>
                        {record.staff_member.first_name}{" "}
                        {record.staff_member.last_name}
                      </h4>
                      <span className="role-badge">
                        {record.staff_member.role}
                      </span>
                    </div>
                    <div className="time-details">
                      <div className="time-row">
                        <span className="label">Check-in:</span>
                        <span className="value">
                          {record.check_in_time
                            ? formatTime(record.check_in_time)
                            : "Not checked in"}
                        </span>
                      </div>
                      <div className="time-row">
                        <span className="label">Check-out:</span>
                        <span className="value">
                          {record.check_out_time
                            ? formatTime(record.check_out_time)
                            : "Not checked out"}
                        </span>
                      </div>
                      {record.hours_worked && (
                        <div className="time-row">
                          <span className="label">Hours worked:</span>
                          <span className="value">{record.hours_worked}h</span>
                        </div>
                      )}
                    </div>
                  </div>
                  <div className="attendance-status">
                    {getStatusBadge(record.status)}
                    {record.status === "pending_approval" && (
                      <LoadingButton
                        onClick={() => handleApproveAttendance(record.id)}
                        loading={buttonLoading[`approve_${record.id}`]}
                        className="approve-btn"
                        size="small"
                      >
                        Approve
                      </LoadingButton>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        <div className="attendance-guidelines">
          <h4>Attendance Rules</h4>
          <ul>
            <li>
              <strong>Present:</strong> Check-in before 1:15 PM
            </li>
            <li>
              <strong>Late:</strong> Check-in after 1:15 PM but before 1:30 AM
              (next day)
            </li>
            <li>
              <strong>Absent:</strong> No check-in recorded by 1:30 AM (next
              day)
            </li>
            <li>
              <strong>Pending Approval:</strong> Requires operator review
            </li>
          </ul>
        </div>
      </div>
    );
  };

  // ✅ Helper function for consistent skeleton loading
  const renderAppointmentSkeleton = (count = 3) => (
    <div className="appointments-skeleton">
      {Array.from({ length: count }, (_, index) => (
        <div key={index} className="appointment-card-skeleton">
          <SkeletonLoader 
            lines={6} 
            avatar={false} 
            className="operator-appointment-skeleton"
            width="100%"
          />
        </div>
      ))}
    </div>
  );

  // ✅ Helper function for refresh indicator
  const renderRefreshIndicator = (message = "Updating data...") =>
    loading && !isInitialLoad && (
      <div className="refresh-indicator">
        <InlineLoader size="small" variant="subtle" />
        <span>{message}</span>
      </div>
    );

  // Render functions for different views  const renderRejectedAppointments = () => {  const renderRejectedAppointments = () => {
    // ✅ Skeleton loading during background refresh
    if (loading && rejectedAppointments.length === 0) {
      return renderAppointmentSkeleton(3);
    }

    if (rejectedAppointments.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-check-circle"></i>
          <p>No pending rejection reviews</p>
        </div>
      );
    }

    return (
      <div className="appointments-list">
        {/* ✅ Show refresh indicator for background updates */}
        {renderRefreshIndicator("Updating rejection reviews...")}
        {rejectedAppointments.map((appointment) => (
          <div key={appointment.id} className="appointment-card rejected">
            <div className="appointment-header">
              <h3>
                Appointment #{appointment.id} -{" "}
                {appointment.client_details?.first_name}{" "}
                {appointment.client_details?.last_name}
              </h3>
              <span className="status-badge rejected">Rejected</span>
            </div>
            <div className="appointment-details">
              <p>
                <strong>Date:</strong>{" "}
                {new Date(appointment.date).toLocaleDateString()}
              </p>
              <p>
                <strong>Time:</strong> {appointment.start_time} -{" "}
                {appointment.end_time}
              </p>
              <p>
                <strong>Location:</strong> {appointment.location}
              </p>
              {renderTherapistInfo(appointment)}
              <p>
                <strong>Rejection Reason:</strong>{" "}
                {appointment.rejection_reason}
              </p>
              <p>
                <strong>Rejected At:</strong>{" "}
                {new Date(appointment.rejected_at).toLocaleString()}
              </p>
            </div>
            <div className="appointment-actions">
              <LoadingButton
                onClick={() => handleReviewRejection(appointment)}
                className="review-button"
              >
                Review Rejection
              </LoadingButton>
            </div>
          </div>
        ))}
      </div>
    );
  };
  const renderPendingAcceptanceAppointments = () => {
    // ✅ Skeleton loading during background refresh
    if (loading && pendingAppointments.length === 0) {
      return renderAppointmentSkeleton(2);
    }

    if (pendingAppointments.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-clock"></i>
          <p>No appointments pending acceptance</p>
        </div>
      );
    }

    return (
      <div className="appointments-list">
        {/* ✅ Show refresh indicator for background updates */}
        {renderRefreshIndicator("Updating pending appointments...")}
        {pendingAppointments.map((appointment) => (
          <div key={appointment.id} className="appointment-card pending">
            <div className="appointment-header">
              <h3>
                Appointment #{appointment.id} -{" "}
                {appointment.client_details?.first_name}{" "}
                {appointment.client_details?.last_name}
              </h3>
              <span className="status-badge pending">Pending</span>
            </div>
            <div className="appointment-details">
              <p>
                <strong>Date:</strong>{" "}
                {new Date(appointment.date).toLocaleDateString()}
              </p>
              <p>
                <strong>Time:</strong> {appointment.start_time} -{" "}
                {appointment.end_time}
              </p>
              <p>
                <strong>Location:</strong> {appointment.location}
              </p>
              {renderTherapistInfo(appointment)}
              <div className="acceptance-status">
                <p>
                  <strong>Therapist Status:</strong>{" "}
                  {getTherapistAcceptanceStatus(appointment)}
                </p>
                <p>
                  <strong>Driver Status:</strong>
                  {appointment.driver_accepted ? (
                    <span className="acceptance-indicator accepted">
                      Accepted ✓
                    </span>
                  ) : (
                    <span className="acceptance-indicator pending">
                      Pending ⏳
                    </span>
                  )}
                </p>
              </div>
            </div>
            <div className="appointment-actions">
              {appointment.both_parties_accepted && (
                <LoadingButton
                  onClick={() => handleStartAppointment(appointment.id)}
                  loading={buttonLoading[`start_${appointment.id}`]}
                  className="start-button"
                >
                  Start Appointment
                </LoadingButton>
              )}
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderTimeoutMonitoring = () => {
    const allTimeoutAppointments = [
      ...overdueAppointments,
      ...approachingDeadlineAppointments,
    ];

    if (allTimeoutAppointments.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-shield-alt"></i>
          <p>No appointments at risk of timeout</p>
        </div>
      );
    }

    return (
      <div className="timeout-section">
        <div className="timeout-actions">
          <LoadingButton
            onClick={handleAutoCancelOverdue}
            loading={autoCancelLoading}
            className="auto-cancel-button"
            variant="danger"
          >
            Auto-Cancel Overdue Appointments
          </LoadingButton>
        </div>

        <div className="appointments-list">
          {allTimeoutAppointments.map((appointment) => {
            const isOverdue = overdueAppointments.some(
              (apt) => apt.id === appointment.id
            );
            return (
              <div
                key={appointment.id}
                className={`appointment-card ${
                  isOverdue ? "overdue" : "approaching-deadline"
                }`}
              >
                <div className="appointment-header">
                  <h3>
                    Appointment #{appointment.id} -{" "}
                    {appointment.client_details?.first_name}{" "}
                    {appointment.client_details?.last_name}
                  </h3>
                  <span
                    className={`status-badge ${
                      isOverdue ? "overdue" : "warning"
                    }`}
                  >
                    {isOverdue ? "Overdue" : "Approaching Deadline"}
                  </span>
                </div>
                <div className="appointment-details">
                  <p>
                    <strong>Date:</strong>{" "}
                    {new Date(appointment.date).toLocaleDateString()}
                  </p>
                  <p>
                    <strong>Time:</strong> {appointment.start_time} -{" "}
                    {appointment.end_time}
                  </p>
                  {renderTherapistInfo(appointment)}
                  <p>
                    <strong>Created:</strong>{" "}
                    {new Date(appointment.created_at).toLocaleString()}
                  </p>
                  {appointment.timeout_deadline && (
                    <p>
                      <strong>Deadline:</strong>{" "}
                      {new Date(appointment.timeout_deadline).toLocaleString()}
                    </p>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  const renderPaymentVerificationView = () => {
    if (awaitingPaymentAppointments.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-credit-card"></i>
          <p>No payments waiting for verification</p>
        </div>
      );
    }

    return (
      <div className="appointments-list">
        {awaitingPaymentAppointments.map((appointment) => (
          <div key={appointment.id} className="appointment-card payment">
            <div className="appointment-header">
              <h3>
                Appointment #{appointment.id} -{" "}
                {appointment.client_details?.first_name}{" "}
                {appointment.client_details?.last_name}
              </h3>
              <span className="status-badge payment">Payment Requested</span>
            </div>
            <div className="appointment-details">
              <p>
                <strong>Date:</strong>{" "}
                {new Date(appointment.date).toLocaleDateString()}
              </p>
              <p>
                <strong>Time:</strong> {appointment.start_time} -{" "}
                {appointment.end_time}
              </p>
              <p>
                <strong>Location:</strong> {appointment.location}
              </p>
              {renderTherapistInfo(appointment)}
              <p>
                <strong>Services:</strong>{" "}
                {appointment.services_details?.map((s) => s.name).join(", ")}
              </p>
              <p>
                <strong>Total Amount:</strong> ₱
                {appointment.services_details
                  ?.reduce((total, service) => total + Number(service.price), 0)
                  .toFixed(2)}
              </p>
              <p>
                <strong>Payment Requested:</strong>{" "}
                {new Date(appointment.payment_requested_at).toLocaleString()}
              </p>
            </div>
            <div className="appointment-actions">
              <LoadingButton
                onClick={() => handlePaymentVerification(appointment)}
                className="verify-payment-button"
              >
                Verify Payment
              </LoadingButton>
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderAllAppointments = () => {
    if (!appointments || appointments.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-calendar"></i>
          <p>No appointments found</p>
        </div>
      );
    }

    return (
      <div className="appointments-list">
        {appointments.map((appointment) => (
          <div key={appointment.id} className="appointment-card">
            <div className="appointment-header">
              <h3>
                Appointment #{appointment.id} -{" "}
                {appointment.client_details?.first_name}{" "}
                {appointment.client_details?.last_name}
              </h3>
              <span className={`status-badge ${appointment.status}`}>
                {appointment.status.charAt(0).toUpperCase() +
                  appointment.status.slice(1).replace(/_/g, " ")}
              </span>
            </div>
            <div className="appointment-details">
              <p>
                <strong>Date:</strong>{" "}
                {new Date(appointment.date).toLocaleDateString()}
              </p>
              <p>
                <strong>Time:</strong> {appointment.start_time} -{" "}
                {appointment.end_time}
              </p>
              <p>
                <strong>Location:</strong> {appointment.location}
              </p>
              {renderTherapistInfo(appointment)}
              <p>
                <strong>Services:</strong>{" "}
                {appointment.services_details?.map((s) => s.name).join(", ")}
              </p>
              <p>
                <strong>Status:</strong> {appointment.status}
              </p>
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderNotifications = () => {
    if (!notifications || notifications.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-bell"></i>
          <p>No notifications</p>
        </div>
      );
    }

    return (
      <div className="notifications-list">
        {notifications.map((notification) => (
          <div
            key={notification.id}
            className={`notification-card ${notification.type}`}
          >
            <div className="notification-header">
              <h4>{notification.title}</h4>
              <span className="notification-time">
                {new Date(notification.created_at).toLocaleString()}
              </span>
            </div>
            <div className="notification-content">
              <p>{notification.message}</p>
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderDriverCoordinationPanel = () => {
    return (
      <div className="driver-coordination-panel">
        <div className="driver-stats">
          <div className="stat-card available">
            <span className="stat-number">
              {driverAssignment.availableDrivers.length}
            </span>
            <span className="stat-label">Available Drivers</span>
          </div>
          <div className="stat-card busy">
            <span className="stat-number">
              {driverAssignment.busyDrivers.length}
            </span>
            <span className="stat-label">Busy Drivers</span>
          </div>
          <div className="stat-card pending">
            <span className="stat-number">{pickupRequests.length}</span>
            <span className="stat-label">Pending Pickups</span>
          </div>
        </div>

        <div className="driver-sections">
          <div className="available-drivers-section">
            <h3>Available Drivers</h3>
            {driverAssignment.availableDrivers.length === 0 ? (
              <p>No drivers currently available</p>
            ) : (
              <div className="drivers-list">
                {driverAssignment.availableDrivers.map((driver) => (
                  <div key={driver.id} className="driver-card available">
                    <div className="driver-info">
                      <h4>
                        {driver.first_name} {driver.last_name}
                      </h4>
                      <p>
                        <strong>Vehicle:</strong> {driver.vehicle_type}
                      </p>
                      <p>
                        <strong>Last Location:</strong> {driver.last_location}
                      </p>
                      <p>
                        <strong>Available Since:</strong>{" "}
                        {new Date(driver.available_since).toLocaleString()}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>

          <div className="busy-drivers-section">
            <h3>Busy Drivers</h3>
            {driverAssignment.busyDrivers.length === 0 ? (
              <p>No drivers currently busy</p>
            ) : (
              <div className="drivers-list">
                {driverAssignment.busyDrivers.map((driver) => (
                  <div key={driver.id} className="driver-card busy">
                    <div className="driver-info">
                      <h4>
                        {driver.first_name} {driver.last_name}
                      </h4>
                      <p>
                        <strong>Current Task:</strong> {driver.current_task}
                      </p>
                      <p>
                        <strong>Vehicle:</strong> {driver.vehicle_type}
                      </p>
                      <p>
                        <strong>Location:</strong> {driver.current_location}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderServiceWorkflowView = () => {
    return (
      <div className="service-workflow-panel">
        <div className="workflow-stats">
          <div className="stat-card">
            <span className="stat-number">{todayAppointments.length}</span>
            <span className="stat-label">Today's Appointments</span>
          </div>
          <div className="stat-card">
            <span className="stat-number">{activeSessions.length}</span>
            <span className="stat-label">Active Sessions</span>
          </div>
          <div className="stat-card">
            <span className="stat-number">{upcomingAppointments.length}</span>
            <span className="stat-label">Upcoming</span>
          </div>
        </div>
        <div className="workflow-content">
          <p>
            Service workflow overview and management tools will be displayed
            here.
          </p>
        </div>
      </div>
    );
  };

  const renderActiveSessionsView = () => {
    if (activeSessions.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-user-md"></i>
          <p>No active therapy sessions</p>
        </div>
      );
    }

    return (
      <div className="appointments-list">
        {activeSessions.map((session) => (
          <div key={session.id} className="appointment-card active-session">
            <div className="appointment-header">
              <h3>
                Session #{session.id} - {session.client_details?.first_name}{" "}
                {session.client_details?.last_name}
              </h3>
              <span className="status-badge active">Active Session</span>
            </div>
            <div className="appointment-details">
              <p>
                <strong>Started:</strong>{" "}
                {new Date(session.session_started_at).toLocaleString()}
              </p>
              <p>
                <strong>Location:</strong> {session.location}
              </p>
              {renderTherapistInfo(session)}
              <p>
                <strong>Services:</strong>{" "}
                {session.services_details?.map((s) => s.name).join(", ")}
              </p>
            </div>
          </div>
        ))}
      </div>
    );
  };

  const renderPickupRequestsView = () => {
    if (pickupRequests.length === 0) {
      return (
        <div className="empty-state">
          <i className="fas fa-car"></i>
          <p>No pickup requests pending</p>
        </div>
      );
    }

    return (
      <div className="pickup-requests-list">
        {pickupRequests.map((request) => (
          <div key={request.id} className="pickup-request-card">
            <div className="request-header">
              <h3>Pickup Request - {request.therapist_name}</h3>
              <span className={`urgency-badge ${request.urgency || "normal"}`}>
                {request.urgency === "urgent" ? "🚨 URGENT" : "⏰ Normal"}
              </span>
            </div>
            <div className="request-details">
              <p>
                <strong>Location:</strong> {request.location}
              </p>
              <p>
                <strong>Requested:</strong>{" "}
                {new Date(request.requested_at).toLocaleString()}
              </p>
              <p>
                <strong>Session Ended:</strong>{" "}
                {new Date(request.session_end_time).toLocaleString()}
              </p>
            </div>
            <div className="request-actions">
              {driverAssignment.availableDrivers.length > 0 ? (
                <div className="driver-assignment">
                  <select
                    onChange={(e) =>
                      e.target.value &&                      handleAssignDriverPickup(
                        request.therapist_id,
                        parseInt(e.target.value)
                      )
                    }
                  >
                    <option value="">Select Driver</option>
                    {driverAssignment.availableDrivers.map((driver) => (
                      <option key={driver.id} value={driver.id}>
                        {driver.first_name} {driver.last_name} -{" "}
                        {driver.vehicle_type}
                      </option>
                    ))}
                  </select>
                  <LoadingButton
                    onClick={() =>
                      handleAssignDriverPickup(request.therapist_id)
                    }
                    className="auto-assign-button"
                  >
                    Auto-Assign (FIFO)
                  </LoadingButton>
                </div>
              ) : (
                <p className="no-drivers">No drivers available</p>
              )}            </div>
          </div>
        ))}
      </div>
    );
  };
  // Main component return - This is the main OperatorDashboard component JSX
  return (
    <PageLayout>
      <div className="operator-dashboard">
        {" "}
        <LayoutRow title="Operator Dashboard">
          <div className="action-buttons">
            <button onClick={handleLogout} className="logout-button">
              Logout
            </button>
          </div>
        </LayoutRow>        {/* ✅ Consistent initial loading with PageLoadingState */}
        {loading && isInitialLoad && (
          <PageLoadingState 
            title="Loading Operator Dashboard"
            subtitle="Fetching appointments, notifications, and system data..."
            showProgress={true}
          />
        )}
        {/* ✅ Consistent error handling with LoadingButton */}
        {error && !isInitialLoad && (
          <div className="error-message">
            <div className="error-content">
              {typeof error === "object"
                ? error.message || error.error || JSON.stringify(error)
                : error}
            </div>
            <LoadingButton
              onClick={() => refreshData()}
              variant="primary"
              size="medium"
              className="retry-button"
            >
              Retry Loading
            </LoadingButton>
          </div>
        )}{" "}
        {/* Statistics Dashboard */}
        <div className="stats-dashboard">
          <div className="stats-card">
            <h4>Rejection Overview</h4>
            <div className="stats-grid">
              <div className="stat-item">
                <span className="stat-number">{rejectionStats.total}</span>
                <span className="stat-label">Total Rejections</span>
              </div>
              <div className="stat-item therapist-stat">
                <span className="stat-number">{rejectionStats.therapist}</span>
                <span className="stat-label">Therapist Rejections</span>
              </div>
              <div className="stat-item driver-stat">
                <span className="stat-number">{rejectionStats.driver}</span>
                <span className="stat-label">Driver Rejections</span>
              </div>
              <div className="stat-item pending-stat">
                <span className="stat-number">{rejectionStats.pending}</span>
                <span className="stat-label">Pending Reviews</span>
              </div>
            </div>
          </div>
        </div>{" "}
        <div className="tab-switcher">
          <button
            className={currentView === "rejected" ? "active" : ""}
            onClick={() => setView("rejected")}
          >
            Pending Reviews ({rejectedAppointments.length})
          </button>
          <button
            className={currentView === "pending" ? "active" : ""}
            onClick={() => setView("pending")}
          >
            Pending Acceptance ({pendingAppointments.length})
          </button>
          <button
            className={currentView === "timeouts" ? "active" : ""}
            onClick={() => setView("timeouts")}
          >
            Timeouts (
            {overdueAppointments.length +
              approachingDeadlineAppointments.length}
            )
          </button>
          <button
            className={currentView === "payment_verification" ? "active" : ""}
            onClick={() => setView("payment_verification")}
          >
            Payment Verification ({awaitingPaymentAppointments.length})
          </button>
          <button
            className={currentView === "all" ? "active" : ""}
            onClick={() => setView("all")}
          >
            All Appointments
          </button>
          <button
            className={currentView === "notifications" ? "active" : ""}
            onClick={() => setView("notifications")}
          >
            Notifications
          </button>
          <button
            className={currentView === "availability" ? "active" : ""}
            onClick={() => setView("availability")}
          >
            Manage Availability
          </button>
          <button
            className={currentView === "drivers" ? "active" : ""}
            onClick={() => setView("drivers")}
          >
            Driver Coordination
          </button>
          <button
            className={currentView === "workflow" ? "active" : ""}
            onClick={() => setView("workflow")}
          >
            Service Workflow
          </button>
          <button
            className={currentView === "active_sessions" ? "active" : ""}
            onClick={() => setView("active_sessions")}
          >
            Active Sessions ({activeSessions.length})
          </button>{" "}
          <button
            className={currentView === "pickup_requests" ? "active" : ""}
            onClick={() => setView("pickup_requests")}
          >
            Pickup Requests ({pickupRequests.length})
          </button>
          <button
            className={currentView === "attendance" ? "active" : ""}
            onClick={() => setView("attendance")}
          >
            Attendance
          </button>
        </div>
        <div
          className={`dashboard-content ${
            paymentModal.isOpen || reviewModal.isOpen ? "faded" : ""
          }`}
        >
          {currentView === "rejected" && (
            <div className="rejected-appointments">
              <h2>Rejection Reviews</h2>
              {renderRejectedAppointments()}
            </div>
          )}
          {currentView === "pending" && (
            <div className="pending-appointments">
              <h2>Pending Acceptance Appointments</h2>
              {renderPendingAcceptanceAppointments()}
            </div>
          )}{" "}
          {currentView === "timeouts" && (
            <div className="timeout-monitoring">
              <h2>Timeout Monitoring</h2>
              {renderTimeoutMonitoring()}
            </div>
          )}
          {currentView === "payment_verification" && (
            <div className="payment-verification">
              <h2>Payment Verification</h2>
              {renderPaymentVerificationView()}
            </div>
          )}
          {currentView === "all" && (
            <div className="all-appointments">
              <h2>All Appointments</h2>
              {renderAllAppointments()}
            </div>
          )}{" "}
          {currentView === "notifications" && (
            <div className="notifications">
              <h2>Notifications</h2>
              {renderNotifications()}
            </div>
          )}{" "}
          {currentView === "availability" && (
            <div className="availability-management">
              <AvailabilityManager />
            </div>
          )}
          {currentView === "drivers" && (
            <div className="driver-coordination">
              <h2>Driver Coordination Center</h2>
              {renderDriverCoordinationPanel()}
            </div>
          )}
          {currentView === "workflow" && (
            <div className="service-workflow">
              <h2>Service Workflow Overview</h2>
              {renderServiceWorkflowView()}
            </div>
          )}
          {currentView === "active_sessions" && (
            <div className="active-sessions">
              <h2>Active Therapy Sessions</h2>
              {renderActiveSessionsView()}
            </div>
          )}{" "}
          {currentView === "pickup_requests" && (
            <div className="pickup-requests">
              <h2>Therapist Pickup Requests</h2>
              {renderPickupRequestsView()}
            </div>
          )}
          {currentView === "attendance" && (
            <div className="attendance-management">
              <h2>Attendance Management</h2>
              {renderAttendanceView()}
            </div>
          )}{" "}
        </div>
      </div>
      {/* End of operator-dashboard */}

      {/* Payment Verification Modal */}
      {paymentModal.isOpen && (
        <div className={styles["modal-overlay"]}>
          <div className={styles.modal}>
            <div className={styles["modal-header"]}>
              <h3>Verify Payment Received</h3>
              <button
                className={styles["close-btn"]}
                onClick={handlePaymentModalCancel}
                aria-label="Close modal"
              >
                ×
              </button>
            </div>
            <div className="appointment-summary">
              <h4>Appointment #{paymentModal.appointmentId}</h4>
              <div className="summary-details">
                <p>
                  <strong>Client:</strong>{" "}
                  {paymentModal.appointmentDetails?.client_details?.first_name
                    ? `${
                        paymentModal.appointmentDetails.client_details
                          .first_name
                      } ${
                        paymentModal.appointmentDetails.client_details
                          .last_name || ""
                      }`.trim()
                    : paymentModal.appointmentDetails?.client ||
                      "Unknown Client"}
                </p>
                <p>
                  <strong>Date:</strong>{" "}
                  {new Date(
                    paymentModal.appointmentDetails?.date
                  ).toLocaleDateString()}
                </p>
                <p>
                  <strong>Services:</strong>{" "}
                  {paymentModal.appointmentDetails?.services_details
                    ?.map((s) => s.name)
                    .join(", ") || "N/A"}
                </p>{" "}
                <p>
                  <strong>Total Amount:</strong> ₱
                  {(() => {
                    const total =
                      paymentModal.appointmentDetails?.services_details?.reduce(
                        (total, service) => {
                          const price = Number(service.price) || 0;
                          return total + price;
                        },
                        0
                      ) || 0;
                    return total.toFixed(2);
                  })()}
                </p>
              </div>
            </div>
            <div className={styles["modal-form"]}>
              <div className="form-group">
                <label htmlFor="paymentMethod">Payment Method:</label>
                <select
                  id="paymentMethod"
                  value={paymentData.method}
                  onChange={(e) =>
                    setPaymentData({ ...paymentData, method: e.target.value })
                  }
                >
                  <option value="cash">Cash</option>
                  <option value="gcash">GCash</option>
                </select>
              </div>

              <div className="form-group">
                <label htmlFor="paymentAmount">Amount Received:</label>
                <input
                  type="number"
                  id="paymentAmount"
                  value={paymentData.amount}
                  onChange={(e) =>
                    setPaymentData({ ...paymentData, amount: e.target.value })
                  }
                  placeholder="Enter amount received"
                  min="0"
                  step="0.01"
                />
              </div>

              <div className="form-group">
                <label htmlFor="paymentNotes">Notes (optional):</label>
                <textarea
                  id="paymentNotes"
                  value={paymentData.notes}
                  onChange={(e) =>
                    setPaymentData({ ...paymentData, notes: e.target.value })
                  }
                  placeholder="Add any notes about the payment..."
                  rows={3}
                />
              </div>

              <div className="modal-actions">
                <LoadingButton
                  className="verify-button"
                  onClick={handleMarkPaymentPaid}
                  loading={
                    buttonLoading[`payment_${paymentModal.appointmentId}`]
                  }
                  loadingText="Processing..."
                >
                  Mark as Paid
                </LoadingButton>
                <LoadingButton
                  className="cancel-button"
                  onClick={handlePaymentModalCancel}
                  variant="secondary"
                >
                  Cancel
                </LoadingButton>
              </div>
            </div>
          </div>
        </div>
      )}
      {/* Review Rejection Modal */}
      {reviewModal.isOpen && (
        <div className="modal-overlay">
          <div className="review-modal">
            <h3>Review Appointment Rejection</h3>
            <div className="rejection-details">
              <p>
                <strong>Rejection Reason:</strong>
              </p>
              <p className="rejection-reason-text">
                {reviewModal.rejectionReason}
              </p>
            </div>
            <div className="review-notes">
              <label htmlFor="reviewNotes">Review Notes (optional):</label>
              <textarea
                id="reviewNotes"
                value={reviewNotes}
                onChange={(e) => setReviewNotes(e.target.value)}
                placeholder="Add any additional notes about your decision..."
                rows={3}
              />
            </div>{" "}
            <div className="modal-actions">
              <LoadingButton
                className="accept-button"
                onClick={() => handleReviewSubmit("accept")}
                loading={
                  buttonLoading[`review_${reviewModal.appointmentId}_accept`]
                }
                loadingText="Processing..."
              >
                Accept Rejection
              </LoadingButton>
              <LoadingButton
                className="deny-button"
                onClick={() => handleReviewSubmit("deny")}
                loading={
                  buttonLoading[`review_${reviewModal.appointmentId}_deny`]
                }
                loadingText="Processing..."
                variant="secondary"
              >
                Deny Rejection{" "}
              </LoadingButton>{" "}
              <LoadingButton
                className="cancel-button"
                onClick={handleReviewCancel}
                variant="secondary"
              >
                {" "}
                Cancel
              </LoadingButton>
            </div>
          </div>
        </div>      )}      {/* End of global-content wrapper closing div is above after modals */}
      {/* Close PageLayout here */}
    </PageLayout>
  );
};

export default OperatorDashboard;
